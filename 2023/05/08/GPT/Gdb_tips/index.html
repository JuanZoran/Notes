<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Gdb-tips | Zoran的个人博客</title><meta name="author" content="Zoran"><meta name="copyright" content="Zoran"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#00c4b6"><meta name="description" content="Zorangdb 还有哪些类似于 enable pretty-printer 这样实用的功能呢  GPT4gdb 提供了许多有用的功能，以帮助您更有效地调试程序。除了 pretty-printers 之外，还有其他一些实用的功能，如下所示：    User-Defined Commands：用户可以创建自定义命令，将多个 gdb 命令组合在一起以简化调试过程。使用 define 命令创建自定义命">
<meta property="og:type" content="article">
<meta property="og:title" content="Gdb-tips">
<meta property="og:url" content="http://juanzoran.github.io/Notes/2023/05/08/GPT/Gdb_tips/index.html">
<meta property="og:site_name" content="Zoran的个人博客">
<meta property="og:description" content="Zorangdb 还有哪些类似于 enable pretty-printer 这样实用的功能呢  GPT4gdb 提供了许多有用的功能，以帮助您更有效地调试程序。除了 pretty-printers 之外，还有其他一些实用的功能，如下所示：    User-Defined Commands：用户可以创建自定义命令，将多个 gdb 命令组合在一起以简化调试过程。使用 define 命令创建自定义命">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back3.jpg">
<meta property="article:published_time" content="2023-05-08T06:11:18.000Z">
<meta property="article:modified_time" content="2023-05-08T07:14:23.122Z">
<meta property="article:author" content="Zoran">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back3.jpg"><link rel="shortcut icon" href="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/favicon.ico"><link rel="canonical" href="http://juanzoran.github.io/Notes/2023/05/08/GPT/Gdb_tips/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Notes/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Notes/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Gdb-tips',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-08 15:14:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#181825')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#00c4b6')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/107862700?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/Notes/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/Notes/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/Notes/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back3.jpg')"><nav id="nav"><span id="blog-info"><a href="/Notes/" title="Zoran的个人博客"><img class="site-icon" src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/zoran.png"/><span class="site-name">Zoran的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Gdb-tips</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-08T06:11:18.000Z" title="发表于 2023-05-08 14:11:18">2023-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-08T07:14:23.122Z" title="更新于 2023-05-08 15:14:23">2023-05-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/Notes/categories/GPT/">GPT</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/Notes/categories/GPT/GDB/">GDB</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/Notes/categories/GPT/GDB/Tips/">Tips</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Gdb-tips"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li><p>Zoran<br>gdb 还有哪些类似于 enable pretty-printer 这样实用的功能呢</p>
</li>
<li><p>GPT4<br><code>gdb</code> 提供了许多有用的功能，以帮助您更有效地调试程序。除了 pretty-printers 之外，还有其他一些实用的功能，如下所示：</p>
</li>
</ul>
<ol>
<li><p><strong>User-Defined Commands</strong>：用户可以创建自定义命令，将多个 <code>gdb</code> 命令组合在一起以简化调试过程。使用 <code>define</code> 命令创建自定义命令，并使用 <code>end</code> 结束命令定义。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define my_cmd</span><br><span class="line">command_1</span><br><span class="line">command_2</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Command History</strong>：<code>gdb</code> 会保存您输入的命令历史，以便您可以通过上下键方便地访问先前使用的命令。</p>
</li>
<li><p><strong>Reverse Debugging</strong>：<code>gdb</code> 支持反向调试，允许您回退到先前的程序状态。使用 <code>reverse-*</code> 命令（如 <code>reverse-step</code>, <code>reverse-next</code>, <code>reverse-continue</code>）在程序的执行历史中向后导航。</p>
</li>
<li><p><strong>Conditional Breakpoints</strong>：您可以设置带有条件表达式的断点，只有当该表达式为真时才会触发断点。例如，您可以使用以下命令在 <code>i</code> 变量等于 5 时设置一个条件断点：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break my_function if i == 5</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Watchpoints</strong>：使用 watchpoints 可以监视特定变量或内存地址的更改。当被监视的变量值发生更改时，<code>gdb</code> 将停止程序的执行。使用 <code>watch</code> 命令设置一个 watchpoint：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch variable_name</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Call Stack Inspection</strong>：使用 <code>bt</code>（backtrace）命令，您可以检查程序的调用堆栈，查看函数调用的顺序和当前的堆栈帧。您还可以使用 <code>frame</code> 命令在不同堆栈帧之间切换。</p>
</li>
<li><p><strong>Thread Debugging</strong>：<code>gdb</code> 支持多线程程序的调试。使用 <code>info threads</code> 命令查看所有可用线程，使用 <code>thread</code> 命令在不同线程之间切换。</p>
</li>
<li><p><strong>Attach and Detach</strong>：您可以使用 <code>gdb</code> 附加到一个正在运行的进程进行调试。使用 <code>attach</code> 命令附加到进程，然后在完成调试后使用 <code>detach</code> 命令从进程中分离。</p>
</li>
<li><p><strong>Remote Debugging</strong>：<code>gdb</code> 可以通过网络远程调试程序。要实现这一点，您需要在目标设备上运行 <code>gdbserver</code>，然后使用 <code>gdb</code> 的 <code>target remote</code> 命令连接到目标设备。</p>
</li>
<li><p><strong>Python Scripting</strong>：从 <code>gdb</code> 7.0 开始，您可以使用 Python 脚本扩展 <code>gdb</code> 的功能。这使得您可以编写更复杂的自定义命令</p>
</li>
</ol>
<h2 id="GDB-奇技淫巧"><a href="#GDB-奇技淫巧" class="headerlink" title="GDB 奇技淫巧"></a>GDB 奇技淫巧</h2><p>Zoran:</p>
<ul>
<li>我希望设置一个全局的 gdb 配置, 比如每次 gdb 调试的时候都首先 tui enable, b main, 应该怎么做</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>您可以创建一个名为 <code>.gdbinit</code> 的文件，该文件包含您希望在启动 <code>gdb</code> 时自动执行的命令。将此文件放置在您的主目录下，或者在您运行 <code>gdb</code> 的当前工作目录下。<code>gdb</code> 在启动时会首先查找这两个位置的 <code>.gdbinit</code> 文件。</li>
</ul>
<p>下面是一个 <code>.gdbinit</code> 文件的示例，该文件自动执行 <code>tui enable</code> 和 <code>b main</code> 命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tui enable</span><br><span class="line"><span class="selector-tag">b</span> <span class="selector-tag">main</span></span><br></pre></td></tr></table></figure>

<p>要创建这个文件，请打开一个文本编辑器，将上述内容粘贴进去，然后将文件保存为 <code>.gdbinit</code>。将此文件放置在您的主目录（<code>~/.gdbinit</code>）或您的当前工作目录下。</p>
<p>现在，当您使用 <code>gdb</code> 调试程序时，它将首先启用 TUI 模式并在 <code>main</code> 函数上设置断点。</p>
<p>如果您希望创建针对特定项目的配置文件，可以将 <code>.gdbinit</code> 文件放在项目目录下。在这种情况下，当您在该目录下运行 <code>gdb</code> 时，将使用该目录下的 <code>.gdbinit</code> 文件。请注意，从 <code>gdb</code> 7.0 开始，为了安全起见，<code>gdb</code> 默认不允许自动加载当前工作目录中的 <code>.gdbinit</code> 文件。要允许这一行为，您需要在主目录的 <code>.gdbinit</code> 文件中添加以下行：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">auto</span>-load local-gdbinit <span class="keyword">on</span></span><br></pre></td></tr></table></figure>

<p>这将允许 <code>gdb</code> 在启动时自动加载当前工作目录下的 <code>.gdbinit</code> 文件。</p>
<p>Zoran:</p>
<ul>
<li>gdb 还有哪些类似于 enable pretty-printer 这样实用的功能呢</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li><code>gdb</code> 提供了许多有用的功能，以帮助您更有效地调试程序。除了 pretty-printers 之外，还有其他一些实用的功能，如下所示：</li>
</ul>
<ol>
<li><strong>User-Defined Commands</strong> ：用户可以创建自定义命令，将多个 <code>gdb</code> 命令组合在一起以简化调试过程。使用 <code>define</code> 命令创建自定义命令，并使用 <code>end</code> 结束命令定义。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">define my_cmd</span><br><span class="line">command_1</span><br><span class="line">command_2</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Command History</strong> ：<code>gdb</code> 会保存您输入的命令历史，以便您可以通过上下键方便地访问先前使用的命令。</li>
<li><strong>Reverse Debugging</strong> ：<code>gdb</code> 支持反向调试，允许您回退到先前的程序状态。使用 <code>reverse-*</code> 命令（如 <code>reverse-step</code>, <code>reverse-next</code>, <code>reverse-continue</code>）在程序的执行历史中向后导航。</li>
<li><strong>Conditional Breakpoints</strong> ：您可以设置带有条件表达式的断点，只有当该表达式为真时才会触发断点。例如，您可以使用以下命令在 <code>i</code> 变量等于 5 时设置一个条件断点：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">break</span> my_function <span class="keyword">if</span> i == <span class="number">5</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>Watchpoints</strong> ：使用 watchpoints 可以监视特定变量或内存地址的更改。当被监视的变量值发生更改时，<code>gdb</code> 将停止程序的执行。使用 <code>watch</code> 命令设置一个 watchpoint：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">watch variable_name</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>Call Stack Inspection</strong> ：使用 <code>bt</code>（backtrace）命令，您可以检查程序的调用堆栈，查看函数调用的顺序和当前的堆栈帧。您还可以使用 <code>frame</code> 命令在不同堆栈帧之间切换。</li>
<li><strong>Thread Debugging</strong> ：<code>gdb</code> 支持多线程程序的调试。使用 <code>info threads</code> 命令查看所有可用线程，使用 <code>thread</code> 命令在不同线程之间切换。</li>
<li><strong>Attach and Detach</strong> ：您可以使用 <code>gdb</code> 附加到一个正在运行的进程进行调试。使用 <code>attach</code> 命令附加到进程，然后在完成调试后使用 <code>detach</code> 命令从进程中分离。</li>
<li><strong>Remote Debugging</strong> ：<code>gdb</code> 可以通过网络远程调试程序。要实现这一点，您需要在目标设备上运行 <code>gdbserver</code>，然后使用 <code>gdb</code> 的 <code>target remote</code> 命令连接到目标设备。</li>
<li><strong>Python Scripting</strong> ：从 <code>gdb</code> 7.0 开始，您可以使用 Python 脚本扩展 <code>gdb</code> 的功能。这使得您可以编写更复杂的自定义命</li>
</ol>
<p>Zoran:</p>
<ul>
<li>(gdb) reverse-step<br>Target native does not support this command.<br>这是什么原因</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li><code>gdb</code> 的反向调试功能并非在所有平台上都受支持。在您遇到的情况下，当您尝试执行 <code>reverse-step</code> 命令时，<code>gdb</code> 返回了 “Target native does not support this command.” 这意味着您所使用的平台不支持反向调试功能。</li>
</ul>
<p>反向调试需要特定的硬件或模拟器支持，因此在许多平台上不可用。通常，在使用基于硬件虚拟化技术（如 QEMU）或使用特定处理器（如支持 Branch Trace Store 的 Intel 处理器）进行调试时，反向调试才可用。</p>
<p>如果您仍希望尝试使用反向调试，可以考虑以下替代方法：</p>
<ol>
<li>使用 QEMU 进行模拟。QEMU 是一个通用的开源计算机模拟器和虚拟化器，支持将目标系统运行在虚拟环境中。您可以将程序在 QEMU 上运行，然后使用 QEMU 的 gdbserver 功能连接到 <code>gdb</code>。在这种配置下，您应该能够使用反向调试。</li>
<li>将程序的执行分解成更小的部分，然后在适当的位置设置断点以便于逐步分析。这样，即使您无法使用反向调试，也可以通过在关键点设置断点来近似反向执行的效果。</li>
</ol>
<p>需要注意的是，这些方法仍可能无法为您提供与实际反向调试相同的功能。但它们至少可以帮助您更好地理解程序的执行过程。</p>
<p>Zoran:</p>
<ul>
<li>有哪些 gdb 的奇技淫巧呢</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li><code>gdb</code> 提供了许多强大的功能，这里列出了一些奇技淫巧，可以帮助您更有效地使用 <code>gdb</code> 进行调试：</li>
</ul>
<ol>
<li><strong>查找函数的源代码位置</strong> ：使用 <code>info functions</code> 命令加上正则表达式，找到与之匹配的函数及其源代码位置。例如：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">info <span class="built_in">functions</span> .*main</span><br></pre></td></tr></table></figure>

<p>这将列出所有包含 “main” 的函数及其在源代码中的位置。 2. <strong>从当前位置运行到指定行</strong> ：使用 <code>until</code> 命令从当前位置运行到指定行。这在你想跳过某个范围内的代码时非常有用。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">until</span> <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>这将运行程序，直到执行到第 42 行。 3. <strong>执行指定次数的命令</strong> ：在命令前加上一个数字，可以执行多次该命令。例如，要执行 5 次 <code>next</code> 命令：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>更改运行时的变量值</strong> ：您可以在调试过程中更改变量的值。这对于测试代码在不同条件下的行为非常有用。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set variable my_variable = <span class="number">42</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>在命令中使用文件名和行号</strong> ：您可以在某些命令中使用文件名和行号，例如设置断点。这在您知道要在特定源文件的特定行上设置断点时非常有用。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">break</span> main.c:<span class="number">42</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>忽略断点的前 N 次触发</strong> ：使用 <code>ignore</code> 命令设置断点的忽略计数。例如，要忽略断点 1 的前 5 次触发：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ignore 1 5</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>将输出重定向到文件</strong> ：在命令后添加 <code>&gt; file_name</code> 将该命令的输出重定向到指定的文件中。例如，将 <code>info registers</code> 的输出保存到名为 <code>registers.txt</code> 的文件中：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">info registers &gt; registers.txt</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><strong>查找内存泄漏</strong> ：使用 <code>gdb</code> 的 <code>malloc_history</code> 命令找到在程序执行期间未释放的内存分配。这可以帮助您识别内存泄漏。</li>
<li>** 为断点添加自动执行的命令** ：使用 <code>commands</code> 命令为断点分配一个或多个自动执行的命令。当断点被触发时，这些命令将自动执行。这对于在断点触发时自动更改变量或显示特定信息非常有用。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">commands <span class="number">1</span></span><br><span class="line">print some_variable</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当断点 1 触发时，它将打印 <code>some_variable</code> 的值</p>
<p>Zoran:</p>
<ul>
<li>继续</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>的值并继续执行。这种自动执行的命令对于观察程序状态变化非常有用，而无需每次都手动输入命令。</li>
</ul>
<ol>
<li>** 命令自动显示变量** ：<code>display</code> 命令允许您在每次程序停止时自动显示一个或多个表达式的值。这可以让您更轻松地观察特定变量在执行过程中的变化。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">display my_variable</span><br></pre></td></tr></table></figure>

<p>这将在每次程序停止时显示 <code>my_variable</code> 的值。 2. ** 保存断点信息** ：如果您在一个调试会话中设置了许多断点，并希望在其他调试会话中重用这些断点，您可以使用 <code>save breakpoints</code> 命令将断点信息保存到一个文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">save breakpoints breakpoints.txt</span><br></pre></td></tr></table></figure>

<p>要在另一个调试会话中加载这些断点，使用 <code>source</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">source</span> breakpoints.txt</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>显示汇编与源代码混合视图</strong> ：使用 <code>layout asm</code> 和 <code>layout src</code> 命令在 TUI 模式下显示汇编与源代码的混合视图。这使您可以在同一界面中查看源代码和对应的汇编代码。</li>
<li><strong>跟踪系统调用</strong> ：使用 <code>catch syscall</code> 命令捕获和跟踪系统调用。您可以使用这个命令来跟踪程序如何与操作系统进行交互。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">catch</span> syscall open</span><br></pre></td></tr></table></figure>

<p>上述命令会在程序尝试打开文件（使用 <code>open</code> 系统调用）时停止执行。</p>
<p>这些奇技淫巧可以让您更高效地使用 <code>gdb</code> 进行调试。然而，请注意，根据您的 <code>gdb</code> 版本和所使用的平台，部分功能可能不可用或需要特定配置才能正常工作。尝试这些技巧时，请务必参考您所使用的 <code>gdb</code> 版本的官方文档。</p>
<p>Zoran:</p>
<ul>
<li>还有哪些技巧呢</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>这里还有一些其他 <code>gdb</code> 技巧，以帮助您在调试过程中提高效率：</li>
</ul>
<ol>
<li><strong>使用别名</strong> ：您可以为频繁使用的命令创建别名，以便快速调用。使用 <code>define</code> 命令创建一个别名：</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">define pname</span><br><span class="line">print variable_name</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为 <code>pname</code> 的别名，执行时将输出 <code>variable_name</code> 的值。 2. <strong>列出源代码</strong> ：使用 <code>list</code> 命令列出当前源文件的内容。您可以指定要显示的行号范围或函数名。例如，要列出 <code>main</code> 函数附近的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">list <span class="selector-tag">main</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>在命令中使用通配符</strong> ：在一些命令中，您可以使用通配符（<code>*</code>）匹配多个项目。例如，您可以一次性删除多个断点：</li>
</ol>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">delete</span> breakpoints *   <span class="comment"># 删除所有断点</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>查找并显示符号信息</strong> ：使用 <code>info symbol</code> 命令可以查找并显示特定内存地址的符号信息。这有助于识别内存地址对应的函数或变量。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">info <span class="built_in">symbol</span> <span class="number">0x400000</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>** 搜索命令和帮助信息** ：如果您无法记住某个命令的名称，可以使用 <code>apropos</code> 命令搜索相关命令和帮助信息。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apropos <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>比较内存中的数据</strong> ：使用 <code>cmp</code> 命令可以比较两个内存地址范围中的数据。例如，比较地址 <code>0x400000</code> 和 <code>0x500000</code> 处的 4 字节：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmp 0x400000 0x500000 4</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>检查内存区域的值</strong> ：使用 <code>x</code>（examine）命令检查内存区域的值。您可以指定要显示的格式和单位。例如，查看以十六进制格式显示的 4 个字（32 位）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x/4xw 0x400000</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><strong>跳转到指定行执行</strong> ：使用 <code>jump</code> 命令可以将程序的执行跳转到指定行。这可以帮助您快速跳过或返回到特定代码段。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jump 42</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><strong>设置命令执行时的超时</strong> ：<code>gdb</code> 提供了 <code>timeout</code> 命令，允许您为命令设置一个超时值。当命令执行超过指定时间时，<code>gdb</code> 会自动停止该命令。这在调试慢速程序或处理器密集型任务时非常有用。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">timeout</span> 5 next</span><br></pre></td></tr></table></figure>

<p>这个命令将在 5 秒后超时，无论 &#96;next</p>
<p>Zoran:</p>
<ul>
<li>继续</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>无论 <code>next</code> 命令是否已经完成。</li>
</ul>
<ol>
<li><strong>监视变量值的变化</strong> ：使用 <code>watch</code> 命令在变量值发生变化时自动中断程序。这对于跟踪可能出现错误的变量非常有用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">watch my_variable</span><br></pre></td></tr></table></figure>

<p>这将在 <code>my_variable</code> 的值发生变化时中断程序。 2. <strong>跟踪函数参数和返回值</strong> ：使用 <code>info args</code> 和 <code>info locals</code> 命令查看当前函数的参数和局部变量。使用 <code>return</code> 命令查看或修改函数的返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">info args</span><br><span class="line">info locals</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>启用和禁用断点</strong> ：您可以使用 <code>enable</code> 和 <code>disable</code> 命令临时启用或禁用断点，而无需删除它们。这在调试过程中管理断点非常有用。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">disable</span> 1</span><br><span class="line"><span class="built_in">enable</span> 1</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>设置条件断点</strong> ：您可以设置一个条件断点，当满足特定条件时才会触发。例如，仅在 <code>my_variable</code> 值大于 10 时触发断点：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">break</span> my_function <span class="keyword">if</span> my_variable &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>记录和回放程序的执行</strong> ：<code>gdb</code> 支持记录程序的执行过程，之后您可以回放这个过程进行分析。使用 <code>record</code> 开始记录，然后使用 <code>stop</code> 停止记录。在记录过程中，您可以使用 <code>next</code>, <code>step</code>, <code>finish</code>, <code>continue</code> 等命令。回放时，使用 <code>reverse-*</code> 命令，如 <code>reverse-next</code>、<code>reverse-step</code> 等。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">record</span><br><span class="line">stop</span><br></pre></td></tr></table></figure>

<p>这些技巧可以帮助您更高效地使用 <code>gdb</code> 调试程序。然而，请注意，根据您的 <code>gdb</code> 版本和所使用的平台，部分功能可能不可用或需要特定配置才能正常工作。尝试这些技巧时，请务必参考您所使用的 <code>gdb</code> 版本的官方文档。</p>
<p>Zoran:</p>
<ul>
<li>这是我的 gdbinit 文件:<br>tui enable<br>enable pretty-printer</li>
</ul>
<p>每次执行 gdb 调试的时候, 都会先弹出这样的其提示, 这是什么原因:<br>None No process In: L?? PC: ??<br>–Type <RET> for more, q to quit, c to continue without paging–</p>
<p>ChatGPT:</p>
<ul>
<li>这个提示来自 <code>gdb</code>，表示 <code>.gdbinit</code> 文件中的命令在启动时被执行。在这种情况下，<code>tui enable</code> 和 <code>enable pretty-printer</code> 在执行时会输出一些信息。</li>
</ul>
<p>问题出在 <code>gdb</code> 启动时没有加载任何程序或进程，因此在执行 <code>.gdbinit</code> 中的命令时，<code>tui enable</code> 试图在没有进程上下文的情况下启用 TUI 模式，从而导致这个提示。</p>
<p>为了解决这个问题，您可以在 <code>.gdbinit</code> 文件中添加一条 <code>if</code> 语句，以确保只在加载了程序或进程的情况下执行 <code>tui enable</code> 和 <code>enable pretty-printer</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if $argc &gt; 0</span><br><span class="line">    tui enable</span><br><span class="line">    enable pretty-printer</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这将确保只有在 <code>gdb</code> 加载了一个程序或进程时，才会执行 <code>tui enable</code> 和 <code>enable pretty-printer</code>。这样一来，您就不会再看到该提示。</p>
<p>Zoran:</p>
<ul>
<li>为什么使用这个脚本之后, 我使用 gdb hello, 来调试命令也没有调用 tui enable 呢</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>抱歉，我在上面的回答中犯了一个错误。使用 <code>$argc</code> 是不正确的，因为 <code>$argc</code> 表示程序的命令行参数个数，而不是 <code>gdb</code> 自己的命令行参数个数。</li>
</ul>
<p>要在 <code>.gdbinit</code> 文件中正确检查 <code>gdb</code> 是否已加载程序，您应该使用下面的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 在 .gdbinit 中检查程序是否已加载</span><br><span class="line">python</span><br><span class="line">import gdb</span><br><span class="line">if len(gdb.execute(&#x27;info files&#x27;, to_string=True).strip()) &gt; 0:</span><br><span class="line">    gdb.execute(&#x27;tui enable&#x27;)</span><br><span class="line">    gdb.execute(&#x27;enable pretty-printer&#x27;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这段脚本使用 Python API，通过执行 <code>info files</code> 命令来检查是否已经加载了程序。当 <code>gdb.execute(&#39;info files&#39;, to_string=True).strip()</code> 的长度大于 0 时，说明已经加载了程序。此时，脚本将执行 <code>tui enable</code> 和 <code>enable pretty-printer</code> 命令。</p>
<p>Zoran:</p>
<ul>
<li>gdb 如何加载 python 脚本文件呢</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>在 GDB 中，可以使用<code>source</code>命令加载并执行 Python 脚本文件。假设您有一个名为<code>myscript.py</code>的 Python 脚本文件，您可以在 GDB 中这样加载它：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">source</span> myscript.py</span><br></pre></td></tr></table></figure>

<p>当您执行此命令时，GDB 将加载<code>myscript.py</code>文件并执行其中的 Python 代码。</p>
<p>此外，您还可以在<code>.gdbinit</code>文件中添加<code>source</code>命令，以便在启动 GDB 时自动加载 Python 脚本。例如，要在启动时自动加载名为<code>myscript.py</code>的脚本，请将以下行添加到<code>.gdbinit</code>文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">source</span> myscript.py</span><br></pre></td></tr></table></figure>

<p>现在，每当您启动 GDB 时，它都会自动加载并执行<code>myscript.py</code>脚本中的 Python 代码。</p>
<p>Zoran:</p>
<ul>
<li>(gdb) source &#x2F;home&#x2F;zoran&#x2F;.gdbinit.py<br>Traceback (most recent call last):<br>File “&#x2F;home&#x2F;zoran&#x2F;.gdbinit.py”, line 5, in <module><br>end<br>NameError: name ‘end’ is not defined<br>(gdb)<br>这是我的 gdbinit.py 文件:<br>❯ cat $HOME&#x2F;.gdbinit.py<br>───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────<br>│ File: &#x2F;home&#x2F;zoran&#x2F;.gdbinit.py<br>───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────<br>1 │ import gdb<br>2 │ if len(gdb.execute(‘info files’, to_string&#x3D;True).strip()) &gt; 0:<br>3 │ gdb.execute(‘tui enable’)<br>4 │ gdb.execute(‘enable pretty-printer’)<br>5 │ end<br>───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>抱歉，我的回答中犯了一个错误。Python 中没有 <code>end</code> 关键字。在 Python 中，您应该使用缩进（空格或制表符）来表示代码块。在您的例子中，您只需删除第 5 行中的 <code>end</code>。</li>
</ul>
<p>修改后的 <code>.gdbinit.py</code> 文件应如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(gdb.execute(<span class="string">&#x27;info files&#x27;</span>, to_string=<span class="literal">True</span>).strip()) &gt; <span class="number">0</span>:</span><br><span class="line">    gdb.execute(<span class="string">&#x27;tui enable&#x27;</span>)</span><br><span class="line">    gdb.execute(<span class="string">&#x27;enable pretty-printer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>现在，当您在 GDB 中使用 <code>source</code> 命令加载此脚本时，应该不会出现错误。</p>
<p>Zoran:</p>
<ul>
<li>gdb 的 set pretty prin on 和 enable pretty-printer 有什么区别</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>在 GDB 中，<code>set print pretty on</code> 和 <code>enable pretty-printer</code> 具有不同的目的，尽管它们看起来类似。</li>
</ul>
<ol>
<li><code>set print pretty on</code>：这个命令用于启用或禁用 GDB 的 “漂亮打印” 功能，用于控制输出的格式。这个设置会改变 GDB 如何显示复杂数据结构（例如结构体、联合体和数组）的默认显示方式。当这个选项被启用（<code>on</code>）时，GDB 将尝试以更易读的方式显示这些数据结构。例如，每个字段都会显示在新行上，并且会添加适当的缩进。您可以使用 <code>set print pretty off</code> 关闭此功能。</li>
</ol>
<p>示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) <span class="function">set print pretty <span class="title">on</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> p my_struct</span></span><br><span class="line"><span class="function">$1 </span>= &#123;</span><br><span class="line">  field1 = <span class="number">42</span>,</span><br><span class="line">  field2 = &#123;</span><br><span class="line">    sub_field1 = <span class="number">3.14</span>,</span><br><span class="line">    sub_field2 = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  field3 = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>enable pretty-printer</code>：这个命令用于启用或禁用已加载的自定义 GDB pretty-printer。这些 pretty-printer 是用 Python 编写的，允许您自定义如何显示特定类型的数据。这对于查看 C++ STL 容器（如 <code>std::vector</code>、<code>std::map</code> 等）和自定义数据结构非常有用。默认情况下，这些 pretty-printer 是启用的，您可以使用 <code>disable pretty-printer</code> 命令关闭它们。</li>
</ol>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) <span class="built_in">enable</span> pretty-printer</span><br><span class="line">(gdb) p my_vector</span><br><span class="line"><span class="variable">$1</span> = std::vector of length 3, capacity 4 = &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>

<p>总之，<code>set print pretty on</code> 控制 GDB 默认的格式化输出，而 <code>enable pretty-printer</code> 控制自定义的 pretty-printer（如 C++ STL 容器）。它们具有不同的用途，可以根据需要启用或禁用。</p>
<p>Zoran:</p>
<ul>
<li>如何使用 gdb 命令查看选项是否是开启的呢</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>要在 GDB 中查看特定选项的当前状态，您可以使用 <code>show</code> 命令。下面是一些示例，展示如何使用 <code>show</code> 命令检查不同选项的状态：</li>
</ul>
<ol>
<li>查看 pretty printing 的状态：</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) show print pretty</span><br></pre></td></tr></table></figure>

<ol>
<li>查看 auto-loading 是否启用：</li>
</ol>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) show auto-load</span><br></pre></td></tr></table></figure>

<ol>
<li>查看当前使用的语言：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) <span class="keyword">show</span> <span class="keyword">language</span></span><br></pre></td></tr></table></figure>

<ol>
<li>查看十六进制显示设置：</li>
</ol>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) show <span class="keyword">print</span> <span class="keyword">hex</span></span><br></pre></td></tr></table></figure>

<p>对于某些设置，可能需要在 <code>show</code> 命令后加上子命令来查看具体的状态，例如查看 pretty-printer 的状态：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) show pretty-printer</span><br></pre></td></tr></table></figure>

<p>此命令将列出已加载的 pretty-printer 以及它们当前是否启用。您可以从输出中判断各个 pretty-printer 的启用状态。</p>
<p>在 GDB 中，您可以使用 <code>help show</code> 命令查看可用的 <code>show</code> 命令。请注意，可用的设置取决于您使用的 GDB 版本和编译选项。您也可以参阅 GDB 的官方文档以获取更详细的信息。</p>
<p>Zoran:</p>
<ul>
<li>“set print elements 0”,<br>这段代码有什么用</li>
</ul>
<p>ChatGPT:</p>
<ul>
<li>在 GDB 中，<code>set print elements</code> 命令用于控制在输出字符串或数组时打印的最大字符数。通过设置一个限制，您可以防止 GDB 输出过长的字符串或数组，从而避免控制台被大量数据淹没。</li>
</ul>
<p><code>set print elements 0</code> 这个命令将最大输出字符数设置为 0，表示没有限制，GDB 将打印完整的字符串或数组。这在查看较长的字符串或数组时可能很有用，但请注意，输出大量数据可能导致 GDB 的响应速度变慢。</p>
<p>您可以使用 <code>set print elements &lt;number&gt;</code> 命令将最大输出字符数设置为一个正整数。例如，如果要限制输出的字符数为 100，可以执行以下命令：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) set print elements <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>此设置后，GDB 在输出字符串或数组时将最多只打印前 100 个字符。要恢复默认设置（通常为 200），您可以执行：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) set print elements <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>要查看当前的最大输出字符数设置，您可以使用 <code>show print elements</code> 命令：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) show print elements</span><br></pre></td></tr></table></figure>

<p>Zoran:</p>
<ul>
<li>我构造了这样一个 NFA 的代码, 我希望通过 gdb 可以将构造的 NFA 自动机的图的状态导出, 可能的方式应该是如何做到呢:<br>#pragma once<br>#include &lt;Util.hpp&gt;<br>#include <cassert><br>#include &lt;color.h&gt;<br>#include <cstdint><br>#include &lt;fmt&#x2F;format.h&gt;<br>#include <fstream><br>#include <map><br>#include <set><br>#include <stack><br>#include <string><br>#include <string_view><br>#include <utility></li>
</ul>
<p>&#x2F;**</p>
<ul>
<li>@class NFA</li>
<li>@brief Thompson algorithm’s NFA</li>
<li>*&#x2F;<br>class NFA<br>{<br>public:<br>using state &#x3D; uint32_t;<br>using size_t &#x3D; uint32_t;<br>using str &#x3D; std::string;<br>using priority_t &#x3D; uint32_t;<br>using str_view &#x3D; std::string_view;</li>
</ul>
<p>public:<br>NFA() &#x3D; default;<br>&#x2F;**<br>_ @brief The wrapper of parse function<br>_<br>_ @tparam Args see parse function<br>_ @param args parse method’s arguments<br>*&#x2F;<br>template &lt;typename… Args&gt;<br>explicit NFA(Args&amp;&amp;… args) noexcept;<br>NFA(NFA&amp;&amp;) &#x3D; default;<br>NFA(const NFA&amp;) &#x3D; default;<br>NFA&amp; operator&#x3D; (NFA&amp;&amp;) &#x3D; default;<br>NFA&amp; operator&#x3D; (const NFA&amp;) &#x3D; default;<br>~NFA() &#x3D; default;</p>
<p>public:<br>void toDiagram(<br>const str&amp; filename, const std::ios_base::openmode flag &#x3D; std::ios::app) const noexcept;<br>void parse(const str RE, str&amp;&amp; info &#x3D; “”, NFA::priority_t priority &#x3D; 1) noexcept;<br>void clear() noexcept;<br>friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const NFA&amp; nfa) noexcept;<br>NFA&amp; operator+ (NFA&amp; rhs) noexcept;</p>
<pre><code>bool match(const str_view&amp; str) const noexcept;
</code></pre>
<p>public:<br>static NFA::str stateInfo() noexcept;</p>
<p>private:<br>static state new_state()<br>{<br>return _size++;<br>}</p>
<p>private:<br>std::map&lt;std::pair&lt;state, char&gt;, state&gt; transition {};<br>std::map&lt;state, std::set<state>&gt; epsilon_transition {};<br>state _start {};<br>state _end {};</p>
<p>private:<br>static std::map&lt;state, std::pair&lt;priority_t, str&gt;&gt; state_info;<br>static size_t _size;<br>str RE {};<br>str postfix {};<br>str pre_process {};<br>};</p>
<p>inline NFA::size_t NFA::_size {};<br>inline std::map&lt;NFA::state, std::pair&lt;NFA::priority_t, NFA::str&gt;&gt; NFA::state_info {};</p>
<p>&#x2F;*</p>
<ul>
<li></li>
<li>INFO :</li>
<li>Thompson algorithm</li>
<li>meta characters : ( ) | _ + ?<br>_&#x2F;<br>template &lt;typename… Args&gt;<br>inline NFA::NFA(Args&amp;&amp;… args) noexcept<br>{<br>parse(std::forward<Args>(args)…);<br>}</li>
</ul>
<p>inline std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const NFA&amp; nfa) noexcept<br>{<br>using namespace Color;</p>
<pre><code>os &lt;&lt; Green &lt;&lt; &quot;start : &quot; &lt;&lt; End &lt;&lt; nfa._start &lt;&lt; &#39;\n&#39;;
os &lt;&lt; Green &lt;&lt; &quot;end : &quot; &lt;&lt; End &lt;&lt; nfa._end &lt;&lt; &#39;\n&#39;;
os &lt;&lt; Green &lt;&lt; &quot;transition : \n&quot;;
for (const auto&amp; [key, value] : nfa.transition) &#123;
    os &lt;&lt; Blue &lt;&lt; key.first &lt;&lt; End &lt;&lt; &quot; -&quot; &lt;&lt; Blue &lt;&lt; key.second &lt;&lt; End &lt;&lt; &quot;-&gt; &quot; &lt;&lt; value
       &lt;&lt; &#39;\n&#39;;
&#125;


os &lt;&lt; Green &lt;&lt; &quot;epsilon transition : \n&quot; &lt;&lt; End;
for (const auto&amp; [key, value] : nfa.epsilon_transition) &#123;
    os &lt;&lt; Yellow &lt;&lt; (key) &lt;&lt; End &lt;&lt; &quot; -&quot;
       &lt;&lt; &quot;epsilon&quot;
       &lt;&lt; &quot;-&gt; &quot;;
    for (const auto&amp; v : value) &#123;
        os &lt;&lt; v &lt;&lt; &#39; &#39;;
    &#125;
    os &lt;&lt; &#39;\n&#39;;
&#125;
return os;
</code></pre>
<p>}</p>
<p>inline void<br>NFA::toDiagram(const std::string&amp; filename, const std::ios_base::openmode flag) const noexcept<br>{<br>using os &#x3D; std::ofstream;<br>os out { filename, flag };<br>assert(out.is_open());</p>
<pre><code>out &lt;&lt; fmt::format(
    &quot;## RE: &#123;&#125;\n&quot;
    &quot;### Preprocess : &#123;&#125;\n&quot;
    &quot;### Postfix : &#123;&#125;\n&quot;
    &quot;```dot\n&quot;
    &quot;digraph G 
</code></pre>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Notes/tags/%E7%BC%96%E7%A8%8B/">编程</a></div><div class="post_share"><div class="social-share" data-image="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Notes/2023/05/08/GPT/CLI_Command/" title="CLI_Command"><img class="cover" src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back3.jpg" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CLI_Command</div></div></a></div><div class="next-post pull-right"><a href="/Notes/2023/05/08/GPT/AwesomeWm_Q_A/" title="AwesomeWm_Q&amp;A"><img class="cover" src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back4.jpg" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AwesomeWm_Q&amp;A</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Notes/2023/05/08/GPT/AwesomeWm_Q_A/" title="AwesomeWm_Q&amp;A"><img class="cover" src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-08</div><div class="title">AwesomeWm_Q&amp;A</div></div></a></div><div><a href="/Notes/2023/05/08/GPT/CLI_Command/" title="CLI_Command"><img class="cover" src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-08</div><div class="title">CLI_Command</div></div></a></div><div><a href="/Notes/2023/05/14/GPT/Compiler_Design/" title="Compiler_Design"><img class="cover" src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-14</div><div class="title">Compiler_Design</div></div></a></div><div><a href="/Notes/2023/05/13/GPT/Git/" title="Git"><img class="cover" src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-13</div><div class="title">Git</div></div></a></div><div><a href="/Notes/2023/05/13/GPT/Linux_Q_A/" title="Linux_Q&amp;A"><img class="cover" src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-13</div><div class="title">Linux_Q&amp;A</div></div></a></div><div><a href="/Notes/2023/05/06/GPT/Lua_QA/" title="Lua_QA"><img class="cover" src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-06</div><div class="title">Lua_QA</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/107862700?v=4" onerror="this.onerror=null;this.src='/Notes/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zoran</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/Notes/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/Notes/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/Notes/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JuanZoran"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JuanZoran" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7"><span class="toc-number">1.</span> <span class="toc-text">GDB 奇技淫巧</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Notes/2024/01/28/Love/demo/" title="demo"><img src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back4.jpg" onerror="this.onerror=null;this.src='/Notes/img/404.jpg'" alt="demo"/></a><div class="content"><a class="title" href="/Notes/2024/01/28/Love/demo/" title="demo">demo</a><time datetime="2024-01-27T21:13:36.000Z" title="发表于 2024-01-28 05:13:36">2024-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Notes/2023/09/08/GPT/Tools/Time/" title="Time"><img src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back1.jpg" onerror="this.onerror=null;this.src='/Notes/img/404.jpg'" alt="Time"/></a><div class="content"><a class="title" href="/Notes/2023/09/08/GPT/Tools/Time/" title="Time">Time</a><time datetime="2023-09-08T06:35:52.000Z" title="发表于 2023-09-08 14:35:52">2023-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Notes/2023/09/08/GPT/Tools/Linnx%20_%20Windows%20Time/" title="Linnx &amp; Windows Time"><img src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back1.jpg" onerror="this.onerror=null;this.src='/Notes/img/404.jpg'" alt="Linnx &amp; Windows Time"/></a><div class="content"><a class="title" href="/Notes/2023/09/08/GPT/Tools/Linnx%20_%20Windows%20Time/" title="Linnx &amp; Windows Time">Linnx &amp; Windows Time</a><time datetime="2023-09-08T06:34:57.000Z" title="发表于 2023-09-08 14:34:57">2023-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Notes/2023/07/24/Misc/photography/" title="读&lt;&lt;摄影构图学&gt;&gt;笔记"><img src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back2.jpg" onerror="this.onerror=null;this.src='/Notes/img/404.jpg'" alt="读&lt;&lt;摄影构图学&gt;&gt;笔记"/></a><div class="content"><a class="title" href="/Notes/2023/07/24/Misc/photography/" title="读&lt;&lt;摄影构图学&gt;&gt;笔记">读&lt;&lt;摄影构图学&gt;&gt;笔记</a><time datetime="2023-07-24T09:13:49.000Z" title="发表于 2023-07-24 17:13:49">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Notes/2023/07/03/Misc/PE_tips/" title="PE_tips"><img src="https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back1.jpg" onerror="this.onerror=null;this.src='/Notes/img/404.jpg'" alt="PE_tips"/></a><div class="content"><a class="title" href="/Notes/2023/07/03/Misc/PE_tips/" title="PE_tips">PE_tips</a><time datetime="2023-07-03T11:04:15.000Z" title="发表于 2023-07-03 19:04:15">2023-07-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://zoran-blog.oss-cn-wuhan-lr.aliyuncs.com/cover/back3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Zoran</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">共同进步!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/Notes/js/utils.js"></script><script src="/Notes/js/main.js"></script><script src="/Notes/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="共同进步,upupup" data-fontsize="8px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>