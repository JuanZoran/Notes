---
title: 右值引用
date: 2023-03-31 23:14:15
categories:
    - C++
    - 现代C++学习
tags:
    - C++
    - 现代C++
    - 编程
---

# 右值引用

## 概念

-   **_左值_**

    **可以**出现在 operator = 左边的

-   **_右值_**

    **只能**出现在 operator = 右边的

-   右值不可取地址

---

### 常用的标准库函数

-   _std::move()_

    该函数只有**让左值绑定到右值引用的函数上**的作用,除此之外,没有任何额外的功能

    使用该函数并**没有任何的作用,不产生任何优化**

-   _std::forward()_

    该函数目的是实现完美转交--**即左值传递后仍然为左值,右值传递后仍然为右值**

    原因参照*左值引用和右值引用均为左值*, (也可以说是有名字的变量都为左值)

---

## 常见右值情况

-   a + b

-   临时对象

-   左值通过**`std::move()`**函数绑定为右值

---

## 使用场景

-   需要对右值单独进行优化,一般是使用浅拷贝

    **需要在右值引用的重载函数中单独实现**

    -   实现时需要注意**传递后需要改变原变量的指向**,否则右值传递后会立即销毁

        如果还指向原变量内容,则原变量的内容就会被销毁,导致后续操作产生*未定义行为*

-   对使用标准库容器的效率进行优化

    -   尤其对 vector 的效率优化效果明显

        主要是因为 vector 在使用的过程中,会发生**_成长_**的行为

        成长过程中,如果有定义**_移动构造_**,会优先调用移动构造函数

        **但前提是确保移动构造函数不会抛出异常**,具体做法是使用*noexcpet*关键字显示声明

    -   标准库容器中,都带有移动拷贝构造和移动赋值函数

        在确保赋值/拷贝构造后,**_原变量不会再继续使用_**,可以使用*std::move()*将原声明的变量绑定到移动拷贝构造/赋值函数上,进行**_浅拷贝_**,来避免不必要的内存分配开销(仅改变指针指向),来实现赋值/拷贝的目的
